/* tooltip plugin for flot
Copyright (c) 2011-2014 Krzysztof Urbas @krzysu [myviews.pl]
Copyright (c) 2012-2014 Petr Blahos @pblahos

This plugin is MIT licensed.

This plugin uses flot-axislabels plugin by Xuan Luo @xuanluo and markitzeronik @markitzeronik
The plugin uses jQuery.NiceScroll plugin by InuYaksa @inuyaksa

The plugin supports these options:
    series: {
        tooltip: false, enable or disable tooltip (default is true)
        tooltipOpts: {
            content: "%s | X: %x | Y: %y" - content of tooltip (%s - series name, %x - X value, %y - Y value), 
                can be:
                a) just a format string,
                b) function of format string and first point coordinates: 
                    function(format, x, y) { return "custom tooltip" }
            xFormat: "%3.2lf" - format string for X value
            yFormat: "%3.2lf" - format string for Y value
            defaultTheme: true - enable/disable default tooltip style
            shifts: { x: 10, y: 20 } - offset from the tooltip position (can be negative as well)
            dateFormat: "%y-%0m-%0d" - date format for vales in time axis mode
            dateFormat: ["%y-%0m-%0d", "%H:%M:%S"] - date format for matched time mode, date format and time format
                year %y, %Y - 2 and 4 digit year
                month %m, %0m - month 1-12 or 01-12
                day %d, %0d - day 1-31 or 01-31
                hour %h, %0h, %H, %0H - hours 1-12 or 01-12 or 0-23 or 00-23
                minutes %M, %0M - minutes 0-59 or 00-59
                seconds %s, %0s - seconds 0-59 or 00-59
                milliseconds %l - milliseconds 0-999
            onHover: function(flotItem, tooltipEl) - callback a point is selected
        }
    }
*/

(function ($) {
    "use strict";

    var FlotTooltip = function (plot) {
        // variables
        this.tipPosition = { x: 0, y: 0 };

        this.init(plot);
    };

    // main plugin function
    FlotTooltip.prototype.init = function (plot) {
        var that = this;

        // tooltip element
        var $tip = $('<div class="flotTip"></div>');
        $tip.appendTo('body').hide();

        // tooltip runs only for first series
        var options = plot.getOptions();
        var processed = false;

        plot.hooks.processOptions.push(function (plot, options) {
            if (processed) return;
            processed = true;

            // add tooltip-specific options to the options structure
            options.tooltipOpts = $.extend(true, {}, FlotTooltip.defaults, options.tooltipOpts);
        });

        plot.hooks.bindEvents.push(function (plot, eventHolder) {
            // check if the tooltip is still visible, and hide if not
            $('body').bind('mouseup', function() {
                if (!$tip.is(':visible')) return;

                var dataset = $tip.data('plot');
                if (!dataset || !dataset.tip || !dataset.tip.series.tooltip || !dataset.tip.series.tooltipOpts.onHover) return;

                dataset.tip.series.tooltipOpts.onHover(undefined, $tip);
                $tip.hide().data('plot', null);
            });

            eventHolder.mouseenter(function(evt) {
                var item = getTooltipItem(evt, plot);
                if (!item) return;

                var tipText = getTooltipText(item);
                if (!tipText) return;

                var tipPosition = getTooltipPosition(evt, plot, item, that.tipPosition);
                showTooltip(tipPosition, tipText, item);

            });

            eventHolder.mousemove(function(evt) {
                var item = getTooltipItem(evt, plot);
                if (!item) {
                    $tip.hide().data('plot', null);
                    return;
                }

                var tipText = getTooltipText(item);
                if (!tipText)
                    return;

                var dataset = $tip.data('plot');
                // check if we still display the same point as the mouse moves
                // and don't update the tooltip if it's the same point
                if (dataset && dataset.tip === item) {
                    var tipPosition = getTooltipPosition(evt, plot, item, that.tipPosition);
                    setTooltipPosition(tipPosition);
                    return;
                }

                var tipPosition = getTooltipPosition(evt, plot, item, that.tipPosition);
                showTooltip(tipPosition, tipText, item);
            });

            eventHolder.mouseleave(function() {
                $tip.hide().data('plot', null);
            });
        });

        function getTooltipItem(evt, plot) {
            var item = null;

            // flot's event.target is set in jquery.flot.js#onClick via which jQuery's event.target is 
            // set in jquery.event.js#fix which is based on the original event
            // so evt.originalEvent (native event) has correct target but we can't assign to it
            // (evt.originalEvent.target = ...) and we need _this_ mousemove event to have the correct
            // target so we assign to evt.target if possible
            
            try { evt.target = evt.originalEvent.target; } catch (e) { }

            var pos = { left: evt.pageX, top: evt.pageY };
            var plotOffset = plot.offset();
            var plotWidth = plot.width();
            var plotHeight = plot.height();

            if (pos.left < plotOffset.left || pos.left > plotOffset.left + plotWidth ||
                pos.top < plotOffset.top || pos.top > plotOffset.top + plotHeight) {
                return null;
            }

            var axes = plot.getAxes();
            var i, j, dataset = plot.getData();

            for (i = 0; i < dataset.length; ++i) {
                var series = dataset[i];

                // return when series is disabled
                if (series.isDisabled && series.isDisabled())
                    continue;

                // return when tooltip is disabled
                if (series.tooltip === false || series.tooltipOpts === false)
                    continue;

                if (series.xaxis.c2p === undefined || series.yaxis.c2p === undefined)
                    continue;

                var xaxis = series.xaxis;
                var yaxis = series.yaxis;
                var x = xaxis.c2p(pos.left - plotOffset.left);
                var y = yaxis.c2p(pos.top - plotOffset.top);

                // return when x is outside the series
                if (x < series.xaxis.min || x > series.xaxis.max)
                    continue;

                for (j = 0; j < series.data.length; j++) {
                    // px and py are float values closest to pos
                    var sx = series.data[j][0];
                    var sy = series.data[j][1];
                    
                    // flot's NaN
                    if (sx === null && sy === null)
                        continue;

                    // compare given coordinates to the one on the graph
                    // using threshold as tolerance
                    var dx = Math.abs(x - sx);
                    var dy = Math.abs(y - sy);
                    var distSq = dx * dx + dy * dy;

                    var threshold = 4; // px squared
                    if (distSq < threshold) {
                        item = {
                            datapoint: series.data[j],
                            dataIndex: j,
                            series: series,
                            seriesIndex: i
                        };
                        break;
                    }
                }
            }
            
            return item;
        }

        function getTooltipText(item) {
            var series = item.series;
            var opts = series.tooltipOpts === undefined ? options.tooltipOpts : series.tooltipOpts;
            var xFormat = opts.xFormat === undefined ? options.tooltipOpts.xFormat : opts.xFormat;
            var yFormat = opts.yFormat === undefined ? options.tooltipOpts.yFormat : opts.yFormat;
            var content = opts.content === undefined ? options.tooltipOpts.content : opts.content;
            var dataX = item.datapoint[0];
            var dataY = item.datapoint[1];

            if (typeof content === 'function') {
                return content(formatLabel(dataX, xFormat, series), formatLabel(dataY, yFormat, series), item);
            }

            if (options.xaxis.mode === 'time' || series.xaxis.mode === 'time') {
                var dateFormat = opts.dateFormat === undefined ? options.tooltipOpts.dateFormat : opts.dateFormat;
                content = content.replace(/%x/g, formatDate(dataX, dateFormat));
            } else {
                content = content.replace(/%x/g, formatLabel(dataX, xFormat, series));
            }
            content = content.replace(/%y/g, formatLabel(dataY, yFormat, series));
            content = content.replace(/%s/g, series.label || '');

            return content;
        }

        function formatLabel(v, format, series) {
            var precision = format === undefined ? series.xaxis.tickDecimals : null;
            var isFloatX = series.xaxis.tickSize.toString().indexOf('.') !== -1;

            if (format) {
                if (format.match(/%p/)) {
                    precision = format.match(/%p(\d{0,})/);
                    if (precision) precision = precision[1];
                    v = v.toFixed(precision ? parseInt(precision, 10) : 2);
                    format = format.replace(/%p\d{0,}/, v);
                } else {
                    // for backwards compatibility
                    format = format.replace(/%x/, v);
                }
                return format;
            }

            if (precision === null) {
                // try to auto-detect precision from the format used by flot
                if (isFloatX) {
                    var x = Math.pow(10, series.xaxis.tickDecimals);
                    precision = Math.max(0, -Math.floor(Math.log(Math.abs(v) / x) / Math.LN10));
                } else {
                    precision = 0;
                }
            }

            // for backwards compatibility
            if (v < 1E-10 && v > -1E-10) {
                return "0";
            } 
            return v.toFixed(precision);
        }

        function formatDate(d, dateFormat) {
            var useUtc = false, hasMilliseconds = false;
            var d = $.plot.dateGenerator(d, {});

            var getDaysInMonth = function(month, year) { return 32 - new Date(year, month, 32).getDate(); };
            var zeroPad = function(n, digits) { var s = String(n); while (s.length < digits) s = "0" + s; return s; };

            var leftPad = function(n, width, z) {
                z = z || '0';
                n = n + '';
                return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
            };

            function replacer(str, p1, p2, p3, p4, p5, p6, p7, p8) {
                var val;
                var format;
                var match;
                var year, month, date, hours, mins, secs, msecs = 0;

                if (typeof d !== 'object') return d;

                if (p1 === '%') return '%';

                format = p8 || p7 || p6 || p5 || p4 || p3 || p2 || p1;
                val = d['get' + (useUtc ? 'UTC' : '') + match[2]]();

                if (match[2] === 'ISO') {
                    var tempDate = new Date(d.getTime());
                    tempDate.setMinutes(tempDate.getMinutes() - tempDate.getTimezoneOffset());
                    return $.plot.formatDate(tempDate, '%Y-%m-%dT%H:%M:%S%z');
                }

                if (match[2] === 'Hours') {
                    if (format.length === 2 && format.charAt(0) === '%') {
                        format = format.charAt(1);
                    }
                    if (format === 'H') {
                        return String(d.getHours());
                    }
                    if (format === 'HH') {
                        return zeroPad(d.getHours(), 2);
                    }
                    if (format === 'h') {
                        var h = d.getHours() % 12;
                        return String(h === 0 ? 12 : h);
                    }
                    if (format === 'hh') {
                        var h = d.getHours() % 12;
                        return zeroPad(h === 0 ? 12 : h, 2);
                    }
                }

                switch(format) {
                    case 'y':
                        return String(d.getFullYear()).substr(2);
                    case 'Y':
                        return String(d.getFullYear());
                    case 'm':
                        return String(d.getMonth() + 1);
                    case '0m':
                        return zeroPad(d.getMonth() + 1, 2);
                    case 'd':
                        return String(d.getDate());
                    case '0d':
                        return zeroPad(d.getDate(), 2);
                    case 'H':
                        return String(d.getHours());
                    case '0H':
                        return zeroPad(d.getHours(), 2);
                    case 'h':
                        return String(d.getHours() % 12 || 12);
                    case '0h':
                        return zeroPad(d.getHours() % 12 || 12, 2);
                    case 'M':
                        return String(d.getMinutes());
                    case '0M':
                        return zeroPad(d.getMinutes(), 2);
                    case 's':
                        return String(d.getSeconds());
                    case '0s':
                        return zeroPad(d.getSeconds(), 2);
                    case 'l':
                        return hasMilliseconds ? zeroPad(d.getMilliseconds(), 3) : '000';
                }

                return format;
            }

            var dateStr = '';

            if (Array.isArray(dateFormat)) {
                var date = new Date(d);
                var day = date.getDate();
                var month = date.getMonth();
                var year = date.getFullYear();
                var hours = date.getHours();
                var mins = date.getMinutes();
                var secs = date.getSeconds();
                var millisecs = date.getMilliseconds();

                var result1 = dateFormat[0]
                    .replace(/%y/g, year.toString().substr(2))
                    .replace(/%Y/g, year.toString())
                    .replace(/%m/g, (month + 1).toString())
                    .replace(/%0m/g, zeroPad(month + 1, 2))
                    .replace(/%d/g, day.toString())
                    .replace(/%0d/g, zeroPad(day, 2));

                var result2 = dateFormat[1]
                    .replace(/%h/g, (hours % 12 || 12).toString())
                    .replace(/%0h/g, zeroPad(hours % 12 || 12, 2))
                    .replace(/%H/g, hours.toString())
                    .replace(/%0H/g, zeroPad(hours, 2))
                    .replace(/%M/g, mins.toString())
                    .replace(/%0M/g, zeroPad(mins, 2))
                    .replace(/%s/g, secs.toString())
                    .replace(/%0s/g, zeroPad(secs, 2))
                    .replace(/%l/g, zeroPad(millisecs, 3));

                return result1 + ' ' + result2;
            }

            if (typeof dateFormat === 'string') {
                var date = new Date(d);
                var day = date.getDate();
                var month = date.getMonth();
                var year = date.getFullYear();
                var hours = date.getHours();
                var mins = date.getMinutes();
                var secs = date.getSeconds();
                var millisecs = date.getMilliseconds();

                return dateFormat
                    .replace(/%y/g, year.toString().substr(2))
                    .replace(/%Y/g, year.toString())
                    .replace(/%m/g, (month + 1).toString())
                    .replace(/%0m/g, zeroPad(month + 1, 2))
                    .replace(/%d/g, day.toString())
                    .replace(/%0d/g, zeroPad(day, 2))
                    .replace(/%h/g, (hours % 12 || 12).toString())
                    .replace(/%0h/g, zeroPad(hours % 12 || 12, 2))
                    .replace(/%H/g, hours.toString())
                    .replace(/%0H/g, zeroPad(hours, 2))
                    .replace(/%M/g, mins.toString())
                    .replace(/%0M/g, zeroPad(mins, 2))
                    .replace(/%s/g, secs.toString())
                    .replace(/%0s/g, zeroPad(secs, 2))
                    .replace(/%l/g, zeroPad(millisecs, 3));
            }

            // fallback format
            return d.toLocaleDateString();
        }

        function getTooltipPosition(evt, plot, item, pos) {
            var series = item.series;
            var opts = series.tooltipOpts === undefined ? options.tooltipOpts : series.tooltipOpts;
            var shifts = opts.shifts === undefined ? options.tooltipOpts.shifts : opts.shifts;

            var plotOffset = plot.offset();
            var point = { x: item.datapoint[0], y: item.datapoint[1] };
            var pointOffset = {
                x: item.series.xaxis.p2c(point.x) + plotOffset.left,
                y: item.series.yaxis.p2c(point.y) + plotOffset.top
            };

            pos.x = pointOffset.x + shifts.x;
            pos.y = pointOffset.y + shifts.y;

            return pos;
        }

        function setTooltipPosition(pos) {
            $tip.css({ left: pos.x, top: pos.y });
        }

        function showTooltip(position, content, item) {
            var dataset = $tip.data('plot') || {};
            dataset.tip = item;
            $tip.data('plot', dataset);

            $tip.html(content);

            // custom styling
            if (options.tooltipOpts.defaultTheme === false) {
                $tip.removeClass('default');
            } else {
                $tip.addClass('default');
            }

            setTooltipPosition(position);
            $tip.show();

            // trigger hook
            var tipOpts = item.series.tooltipOpts || options.tooltipOpts;
            if (tipOpts && typeof tipOpts.onHover === 'function') {
                tipOpts.onHover(item, $tip);
            }
        }
    };

    FlotTooltip.defaults = {
        xFormat: null,
        yFormat: null,
        dateFormat: '%y-%0m-%0d',
        content: '%s | X: %x | Y: %y',
        // don't change defaultTheme to maintain backward compatibility
        defaultTheme: true,
        shifts: {
            x: 10,
            y: -20
        }
    };

    $.plot.plugins.push({
        init: function(plot) {
            new FlotTooltip(plot);
        },
        options: FlotTooltip.defaults,
        name: 'tooltip',
        version: '0.8.5'
    });

})(jQuery); 